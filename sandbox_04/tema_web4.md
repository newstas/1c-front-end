# WEB-I ТЕМА 4 — JavaScript. DOM, переменные и функции

```js
var firstName = "John", lastName = "Doe";
var fullName = firstName + " " + lastName;
```


# Структура кода

[Структура кода](https://learn.javascript.ru/structure)

Начнём изучение языка с рассмотрения основных «строительных блоков» кода.


## Инструкции

**Инструкции – это синтаксические конструкции и команды, которые выполняют действия.**

Мы уже видели инструкцию `alert('Привет, мир!')`, которая отображает сообщение «Привет, мир!».

В нашем коде может быть столько инструкций, сколько мы захотим. Инструкции могут отделяться точкой с запятой.

Например, здесь мы разделили сообщение «Привет Мир» на два вызова `alert`:

```js
alert('Привет'); alert('Мир');
```

Обычно каждую инструкцию пишут на новой строке, чтобы код было легче читать:

```js
alert('Привет');
alert('Мир');
```

## Точка с запятой

В большинстве случаев точку с запятой можно не ставить, если есть переход на новую строку.

Так тоже будет работать:
```
alert('Привет')
alert('Мир')
```
В этом случае **JavaScript интерпретирует перенос строки как «неявную» точку с запятой**.
Это называется **автоматическая вставка точки с запятой**.

В большинстве случаев новая строка подразумевает точку с запятой. Но «в большинстве случаев» не значит «всегда»!

В некоторых ситуациях новая строка всё же не означает точку с запятой. Например:
```
alert(3 +
1
+ 2);
```
Код выведет 6, потому что JavaScript не вставляет здесь точку с запятой. Интуитивно очевидно, что, если строка заканчивается знаком "+", значит, это «незавершённое выражение», поэтому точка с запятой не требуется. И в этом случае всё работает, как задумано.

Но есть ситуации, где JavaScript «забывает» вставить точку с запятой там, где она нужна.


## Комментарии

Со временем программы становятся всё сложнее и сложнее. Возникает необходимость добавлять комментарии, которые бы описывали, что делает код и почему.
Комментарии могут находиться в любом месте скрипта. Они не влияют на его выполнение, поскольку движок просто игнорирует их.


### `//` однострочные комментарии

**Однострочные комментарии начинаются с двойной косой черты `//`.**

Часть строки после `//` считается комментарием. Такой комментарий может как занимать строку целиком, так и находиться после инструкции.


### /*    */ многострочные комментарии

**Многострочные комментарии начинаются косой чертой со звёздочкой `/*` и заканчиваются звёздочкой с косой чертой `*/`.**


# DOM (Document Object Model)

**Document Object Model**, сокращённо **DOM** – объектная модель документа, которая представляет все содержимое страницы в виде объектов, которые можно менять.

Объект document – основная «входная точка». С его помощью мы можем что-то создавать или менять на странице.

Например:

```js
// заменим цвет фона на красный,
document.body.style.background = "red";
```

## Браузерное окружение, спецификации

Язык JavaScript изначально был создан для веб-браузеров. Но с тех пор он значительно эволюционировал и превратился в кроссплатформенный язык программирования для решения широкого круга задач.

Сегодня JavaScript может использоваться в браузере, на веб-сервере или в какой-то другой среде, даже в кофеварке. Каждая среда предоставляет свою функциональность, которую спецификация JavaScript называет окружением.

Окружение предоставляет свои объекты и дополнительные функции, в дополнение базовым языковым. Браузеры, например, дают средства для управления веб-страницами. Node.js делает доступными какие-то серверные возможности и так далее.

На картинке ниже в общих чертах показано, что доступно для JavaScript в браузерном окружении:

![DOM](https://github.com/shkolait/picture/blob/main/1c-front-end/pic1/DOM-%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C.png)


## BOM (Browser Object Model)

Объектная модель браузера (**Browser Object Model, BOM**) – это дополнительные объекты, предоставляемые браузером (окружением), чтобы работать со всем, кроме документа.

Например:

- Объект **navigator**` даёт информацию о самом браузере и операционной системе. Среди множества его свойств самыми известными являются: `navigator.userAgent` – информация о текущем браузере, и `navigator.platform` – информация о платформе (может помочь в понимании того, в какой ОС открыт браузер – Windows/Linux/Mac и так далее).

- Объект **location** позволяет получить текущий URL и перенаправить браузер по новому адресу.


### Итого

Говоря о стандартах, у нас есть:

**Спецификация DOM**

- описывает структуру документа, манипуляции с контентом и события, подробнее на https://dom.spec.whatwg.org.

**Спецификация CSSOM (CSS Object Model)**

- описывает файлы стилей, правила написания стилей и манипуляций с ними, а также то, как это всё связано со страницей, подробнее на https://www.w3.org/TR/cssom-1/.

**Спецификация HTML**

- описывает язык HTML (например, теги) и BOM (объектную модель браузера) – разные функции браузера: setTimeout, alert, location и так далее, подробнее на https://html.spec.whatwg.org. Тут берётся за основу спецификация DOM и расширяется дополнительными свойствами и методами.

Кроме того, некоторые классы описаны отдельно на https://spec.whatwg.org/.


## Поиск: `getElement*`, `querySelector*`

Есть 6 основных методов поиска элементов в DOM:

Метод                     | Ищет по...   | Ищет внутри элемента? | Возвращает живую коллекцию?
---                       | ---          | ---                   | ---
`querySelector`	          | CSS-selector | ✔                    | -
`querySelectorAll`	       | CSS-selector | ✔                    | -
`getElementById`          | id           | -                     | -
`getElementsByName`       | name         | -                     | ✔
`getElementsByTagName`    | tag or '*'   | ✔                    | ✔
`getElementsByClassName`  | class        | ✔                    | ✔



### Поисковый метод `document.getElementById` или просто `id`

Если у элемента есть атрибут id, то мы можем получить его 
вызовом `document.getElementById(id)`, где бы он ни находился.


### Поисковый метод `querySelector*`

`querySelectorAll`

Самый универсальный метод поиска – это `elem.querySelectorAll(css)`, он возвращает 
все элементы внутри elem, удовлетворяющие данному CSS-селектору.

`querySelector`

Метод `elem.querySelector(css)` возвращает первый элемент, соответствующий данному 
CSS-селектору.


## Выводим `HTML`
HTML элементы в консоли можно исследовать так же, как в инспекторе:
```
let element = document.getElementsByTagName("body") [0];
console.log(element);
```


# Введение в браузерные события

Событие – это сигнал от браузера о том, что что-то произошло. Все DOM-узлы подают такие сигналы (хотя события бывают и не только в DOM).

Вот список самых часто используемых DOM-событий, пока просто для ознакомления:


### События мыши:

- `click` – происходит, когда кликнули на элемент левой кнопкой мыши (на устройствах с сенсорными экранами оно происходит при касании).

- `contextmenu` – происходит, когда кликнули на элемент правой кнопкой мыши.

- `mouseover / mouseout` – когда мышь наводится на / покидает элемент.

- `mousedown / mouseup` – когда нажали / отжали кнопку мыши на элементе.

- `mousemove` – при движении мыши.


### События на элементах управления:

- `submit` – пользователь отправил форму `<form>`.

- `focus` – пользователь фокусируется на элементе, например нажимает на `<input>`.


### Клавиатурные события:

- `keydown` и `keyup` – когда пользователь нажимает / отпускает клавишу.


### События документа:

- `DOMContentLoaded` – когда HTML загружен и обработан, DOM документа полностью построен и доступен.

### CSS events:

`transitionend` – когда CSS-анимация завершена.

Существует множество других событий.


## Обработчики событий

**Событию можно назначить *обработчик***, то есть *функцию, которая сработает, как только событие произошло*.

Именно благодаря обработчикам JavaScript-код может реагировать на действия пользователя.

Есть несколько способов назначить событию обработчик. Сейчас мы их рассмотрим, начиная с самого простого.


### Использование атрибута HTML

Обработчик может быть назначен прямо в разметке, в атрибуте, который называется `on<событие>`.

Например, чтобы назначить обработчик события `click` на элементе `input`, можно использовать атрибут `onclick`, вот так:

`<input value="Нажми меня" onclick="alert('Клик!')" type="button">`

При клике мышкой на кнопке выполнится код, указанный в атрибуте `onclick`.

Обратите внимание, для содержимого атрибута `onclick` используются одинарные кавычки, так как сам атрибут находится в двойных. Если мы забудем об этом и поставим двойные кавычки внутри атрибута, вот так:` onclick="alert("Click!")"`, код не будет работать.

Атрибут HTML-тега – не самое удобное место для написания большого количества кода, поэтому лучше создать отдельную JavaScript-функцию и вызвать её там.

Атрибут HTML-тега не чувствителен к регистру, поэтому `ONCLICK` будет работать так же, как `onClick` и `onCLICK`… Но, как правило, атрибуты пишут в нижнем регистре: `onclick`.


### Использование свойства DOM-объекта

Можно назначать обработчик, используя свойство DOM-элемента `on<событие>`.

К примеру, `elem.onclick`


## Метод `addEventListener()`

Фундаментальный недостаток описанных выше способов назначения обработчика – невозможность повесить несколько обработчиков на одно событие.

Разработчики стандартов достаточно давно это поняли и предложили альтернативный способ назначения обработчиков при помощи специальных методов `addEventListener` и `removeEventListener`. Они свободны от указанного недостатка.

Используйте элемент `addEventListener()` для присоединения обработчика событий 
к указанному элементу.


### Синтаксис добавления обработчика:

`element.addEventListener(event, handler[, options]);`

где:

`event` - имя события, например "click".

`handler` - ссылка на функцию-обработчик.

`options` - дополнительный объект со свойствами:

- `once`: если true, тогда обработчик будет автоматически удалён после выполнения.

- `capture`: фаза, на которой должен сработать обработчик, подробнее об этом будет рассказано в главе [Всплытие и погружение](https://learn.javascript.ru/bubbling-and-capturing). Так исторически сложилось, что options может быть `false`/`true`, это тоже самое, что `{capture: false/true}`.

- `passive`: если `true`, то указывает, что обработчик никогда не вызовет `preventDefault()`, подробнее об этом будет рассказано в главе Действия браузера по умолчанию.


### Для удаления обработчика следует использовать `removeEventListener`:
```
element.removeEventListener(event, handler[, options]);
```

 
 

***

[Структура кода](https://learn.javascript.ru/structure)

[Особенности JavaScript](https://learn.javascript.ru/javascript-specials)

[Переменные](https://learn.javascript.ru/variables)

[Функции](https://learn.javascript.ru/function-basics)

[Function Expression (Функциональное Выражение)](https://learn.javascript.ru/function-expressions)

[Типы данных](https://learn.javascript.ru/types)


[Курс JavaScript - Основные концепции и особенности разработки](http://jsflow.org/)



[Введение в браузерные события](https://learn.javascript.ru/introduction-browser-events)


[Используем console.log() в Chrome на полную](https://habr.com/ru/post/480700/)
