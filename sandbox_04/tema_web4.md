# WEB-I ТЕМА 4 — JavaScript. DOM, переменные и функции

```js
var firstName = "John", lastName = "Doe";
var fullName = firstName + " " + lastName;
```

 
 # Грамматика и типы

JavaScript заимствует большую часть синтаксиса из Java, но также испытал 
влияние таких языков, как **Awk**, **Perl** и **Python**.

JavaScript **чувствителен к регистру** и использует кодировку символов **Unicode**

> В информатике термин инструкция обозначает одну отдельную операцию процессора, 
> определённую системой команд/
> В более широком понимании, «инструкцией» может быть любое представление 
> элемента исполнимой программы, такой как байт-код.

В JavaScript инструкции называются **statements** и разделяются точкой с запятой 
`;`. Пробел (**space**), табуляция (**tab**) и перевод строки (**newline**) 
называются пробельными символами (**whitespace**).

Исходный текст скриптов на JavaScript **сканируется слева направо** и 
конвертируется в последовательность входных элементов, являющихся 
токенами (**tokens**), управляющими символами, символами конца строки, 
комментариями или пробельными символами.

ECMAScript также **определяет некоторые ключевые слова и литералы** и 
**устанавливает правила для автоматической вставки точек с запятой** (ASI), 
чтобы обозначить конец инструкций (statements). Однако, рекомендуется всегда 
ставить точку с запятой в конце каждой инструкции вручную, чтобы избежать 
побочных эффектов.

# Объявления

В JavaScript существует три вида объявлений:

- `var` - **объявляет переменную**, инициализация переменной значением является 
необязательной

- `let` - **объявляет локальную переменную** в области видимости блока, 
инициализация переменной значением является необязательной.

- `const` - **объявляет именованную константу**, доступную только для чтения. 


## Объявление переменных

Вы можете объявить переменную тремя способами:

- `var x = 42` -  используя **ключевое слово** `var`. Данный синтаксис может 
быть использован для объявления как локальных, так и глобальных переменных.
    
- `x = 42` - **просто присвоить переменной значение**. Переменные, объявленные 
данным способом, являются глобальными. Такое объявление генерирует строгое 
предупреждение  (strict mode). Не рекомендуется использовать данный способ.
    
- `let y = 13`- **используя ключевое слово** `let`. Данный синтаксис может быть 
использован для объявления локальной переменной в области видимости блока.


## Присваивание значений

Переменная, объявленная через `var` или `let` **без присвоения начального 
значения**, имеет значение `undefined`.

При попытке доступа **к необъявленной переменной или переменной до её 
объявления** будет выброшено исключение `ReferenceError`.

До ECMAScript 6 в JavaScript отсутствовала область видимости блока; 
переменная, объявленная внутри блока, является локальной для функции 
(или глобальной области видимости), внутри которой находится данный блок.


## Константы

Вы можете создать именованную константу, доступную только для чтения, 
используя ключевое слово `const`. 


# Структуры и типы данных


## Типы данных

Последний стандарт ECMAScript определяет семь типов данных:

- Шесть типов данных,  которые являются примитивами:
  - `Boolean` - со значениями `true` и `false`.
  - `null`. Специальное ключевое слово, обозначающее нулевое или «пустое» значение. 
Поскольку JavaScript чувствителен к регистру, `null` не то же самое, что `Null`, `NULL` или любой другой вариант.
  - `undefined`. Свойство глобального объекта; **переменная, не имеющая присвоенного значения, обладает типом `undefined**`.
  - `Number`- `наример:` `42` или `3.14159`.
  - String -  например: `"Howdy"`.
  - `Symbol` (ECMAScript 6)
- и `Object`

Хотя типов данных относительно немного, но они позволяют вам выполнять полезные 
функции в ваших приложениях. 

**Объекты** и **функции** - являются **другими фундаментальными элементами языка**. 
Вы можете **думать об объектах** как **об именованных контейнерах для значений** 
и **о функциях - как о процедурах, которые ваше приложение может исполнять**.


## Литералы

Литералы используются для представления значений в JavaScript. 
Они являются фиксированными значениями, а не переменными. 

Рассмотрим следующие типы литералов:

- Литерал массива
- Логический литерал
- Литерал целого числа
- Литерал числа с плавающей точкой
- Литерал объекта
- RegExp литерал
- Литерал строки


# Структура кода

[Структура кода](https://learn.javascript.ru/structure)

Начнём изучение языка с рассмотрения основных «строительных блоков» кода.


## Инструкции

**Инструкции – это синтаксические конструкции и команды, которые выполняют действия.**

Мы уже видели инструкцию `alert('Привет, мир!')`, которая отображает сообщение «Привет, мир!».

В нашем коде может быть столько инструкций, сколько мы захотим. Инструкции могут отделяться точкой с запятой.

Например, здесь мы разделили сообщение «Привет Мир» на два вызова `alert`:

```js
alert('Привет'); alert('Мир');
```

Обычно каждую инструкцию пишут на новой строке, чтобы код было легче читать:

```js
alert('Привет');
alert('Мир');
```

## Точка с запятой

В большинстве случаев точку с запятой можно не ставить, если есть переход на новую строку.

Так тоже будет работать:
```
alert('Привет')
alert('Мир')
```
В этом случае **JavaScript интерпретирует перенос строки как «неявную» точку с запятой**.
Это называется **автоматическая вставка точки с запятой**.

В большинстве случаев новая строка подразумевает точку с запятой. Но «в большинстве случаев» не значит «всегда»!

В некоторых ситуациях новая строка всё же не означает точку с запятой. Например:
```
alert(3 +
1
+ 2);
```
Код выведет 6, потому что JavaScript не вставляет здесь точку с запятой. Интуитивно очевидно, что, если строка заканчивается знаком "+", значит, это «незавершённое выражение», поэтому точка с запятой не требуется. И в этом случае всё работает, как задумано.

Но есть ситуации, где JavaScript «забывает» вставить точку с запятой там, где она нужна.


## Комментарии

Со временем программы становятся всё сложнее и сложнее. Возникает необходимость добавлять комментарии, которые бы описывали, что делает код и почему.
Комментарии могут находиться в любом месте скрипта. Они не влияют на его выполнение, поскольку движок просто игнорирует их.


### `//` однострочные комментарии

**Однострочные комментарии начинаются с двойной косой черты `//`.**

Часть строки после `//` считается комментарием. Такой комментарий может как занимать строку целиком, так и находиться после инструкции.


### /*    */ многострочные комментарии

**Многострочные комментарии начинаются косой чертой со звёздочкой `/*` и заканчиваются звёздочкой с косой чертой `*/`.**


# DOM (Document Object Model)

**Document Object Model**, сокращённо **DOM** – объектная модель документа, которая представляет все содержимое страницы в виде объектов, которые можно менять.

Объект document – основная «входная точка». С его помощью мы можем что-то создавать или менять на странице.

Например:

```js
// заменим цвет фона на красный,
document.body.style.background = "red";
```

## Браузерное окружение, спецификации

Язык JavaScript изначально был создан для веб-браузеров. Но с тех пор он значительно эволюционировал и превратился в кроссплатформенный язык программирования для решения широкого круга задач.

Сегодня JavaScript может использоваться в браузере, на веб-сервере или в какой-то другой среде, даже в кофеварке. Каждая среда предоставляет свою функциональность, которую спецификация JavaScript называет окружением.

Окружение предоставляет свои объекты и дополнительные функции, в дополнение базовым языковым. Браузеры, например, дают средства для управления веб-страницами. Node.js делает доступными какие-то серверные возможности и так далее.

На картинке ниже в общих чертах показано, что доступно для JavaScript в браузерном окружении:

![DOM](https://github.com/shkolait/picture/blob/main/1c-front-end/pic1/DOM-%D0%BC%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C.png)


## BOM (Browser Object Model)

Объектная модель браузера (**Browser Object Model, BOM**) – это дополнительные объекты, предоставляемые браузером (окружением), чтобы работать со всем, кроме документа.

Например:

- Объект **navigator**` даёт информацию о самом браузере и операционной системе. Среди множества его свойств самыми известными являются: `navigator.userAgent` – информация о текущем браузере, и `navigator.platform` – информация о платформе (может помочь в понимании того, в какой ОС открыт браузер – Windows/Linux/Mac и так далее).

- Объект **location** позволяет получить текущий URL и перенаправить браузер по новому адресу.


### Итого

Говоря о стандартах, у нас есть:

**Спецификация DOM**

- описывает структуру документа, манипуляции с контентом и события, подробнее на https://dom.spec.whatwg.org.

**Спецификация CSSOM (CSS Object Model)**

- описывает файлы стилей, правила написания стилей и манипуляций с ними, а также то, как это всё связано со страницей, подробнее на https://www.w3.org/TR/cssom-1/.

**Спецификация HTML**

- описывает язык HTML (например, теги) и BOM (объектную модель браузера) – разные функции браузера: setTimeout, alert, location и так далее, подробнее на https://html.spec.whatwg.org. Тут берётся за основу спецификация DOM и расширяется дополнительными свойствами и методами.

Кроме того, некоторые классы описаны отдельно на https://spec.whatwg.org/.


## Поиск: `getElement*`, `querySelector*`

Есть 6 основных методов поиска элементов в DOM:

Метод                     | Ищет по...   | Ищет внутри элемента? | Возвращает живую коллекцию?
---                       | ---          | ---                   | ---
`querySelector`	          | CSS-selector | ✔                    | -
`querySelectorAll`	       | CSS-selector | ✔                    | -
`getElementById`          | id           | -                     | -
`getElementsByName`       | name         | -                     | ✔
`getElementsByTagName`    | tag or '*'   | ✔                    | ✔
`getElementsByClassName`  | class        | ✔                    | ✔



### Поисковый метод `document.getElementById` или просто `id`

Если у элемента есть атрибут id, то мы можем получить его 
вызовом `document.getElementById(id)`, где бы он ни находился.


### Поисковый метод `querySelector*`

`querySelectorAll`

Самый универсальный метод поиска – это `elem.querySelectorAll(css)`, он возвращает 
все элементы внутри elem, удовлетворяющие данному CSS-селектору.

`querySelector`

Метод `elem.querySelector(css)` возвращает первый элемент, соответствующий данному 
CSS-селектору.


## Находим и выводим `HTML`

HTML элементы в консоли можно исследовать так же, как в инспекторе:

```
let element = document.getElementsByTagName("body") [0];
console.log(element);
```


# Введение в браузерные события

Событие – это сигнал от браузера о том, что что-то произошло. Все DOM-узлы подают такие сигналы (хотя события бывают и не только в DOM).

Вот список самых часто используемых DOM-событий, пока просто для ознакомления:


### События мыши:

- `click` – происходит, когда кликнули на элемент левой кнопкой мыши (на устройствах с сенсорными экранами оно происходит при касании).

- `contextmenu` – происходит, когда кликнули на элемент правой кнопкой мыши.

- `mouseover / mouseout` – когда мышь наводится на / покидает элемент.

- `mousedown / mouseup` – когда нажали / отжали кнопку мыши на элементе.

- `mousemove` – при движении мыши.


### События на элементах управления:

- `submit` – пользователь отправил форму `<form>`.

- `focus` – пользователь фокусируется на элементе, например нажимает на `<input>`.


### Клавиатурные события:

- `keydown` и `keyup` – когда пользователь нажимает / отпускает клавишу.


### События документа:

- `DOMContentLoaded` – когда HTML загружен и обработан, DOM документа полностью построен и доступен.

### CSS events:

`transitionend` – когда CSS-анимация завершена.

Существует множество других событий.


## Обработчики событий

**Событию можно назначить *обработчик***, то есть *функцию, которая сработает, как только событие произошло*.

Именно благодаря обработчикам JavaScript-код может реагировать на действия пользователя.

Есть несколько способов назначить событию обработчик. Сейчас мы их рассмотрим, начиная с самого простого.


### Использование атрибута HTML

Обработчик может быть назначен прямо в разметке, в атрибуте, который называется `on<событие>`.

Например, чтобы назначить обработчик события `click` на элементе `input`, можно использовать атрибут `onclick`, вот так:

`<input value="Нажми меня" onclick="alert('Клик!')" type="button">`

При клике мышкой на кнопке выполнится код, указанный в атрибуте `onclick`.

Обратите внимание, для содержимого атрибута `onclick` используются одинарные кавычки, так как сам атрибут находится в двойных. Если мы забудем об этом и поставим двойные кавычки внутри атрибута, вот так:` onclick="alert("Click!")"`, код не будет работать.

Атрибут HTML-тега – не самое удобное место для написания большого количества кода, поэтому лучше создать отдельную JavaScript-функцию и вызвать её там.

Атрибут HTML-тега не чувствителен к регистру, поэтому `ONCLICK` будет работать так же, как `onClick` и `onCLICK`… Но, как правило, атрибуты пишут в нижнем регистре: `onclick`.


### Использование свойства DOM-объекта

Можно назначать обработчик, используя свойство DOM-элемента `on<событие>`.

К примеру, `elem.onclick`


## Метод `addEventListener()`

Фундаментальный недостаток описанных выше способов назначения обработчика – невозможность повесить несколько обработчиков на одно событие.

Разработчики стандартов достаточно давно это поняли и предложили альтернативный способ назначения обработчиков при помощи специальных методов `addEventListener` и `removeEventListener`. Они свободны от указанного недостатка.

Используйте элемент `addEventListener()` для присоединения обработчика событий 
к указанному элементу.


### Синтаксис добавления обработчика:

`element.addEventListener(event, handler[, options]);`

где:

`event` - имя события, например "click".

`handler` - ссылка на функцию-обработчик.

`options` - дополнительный объект со свойствами:

- `once`: если true, тогда обработчик будет автоматически удалён после выполнения.

- `capture`: фаза, на которой должен сработать обработчик, подробнее об этом будет рассказано в главе [Всплытие и погружение](https://learn.javascript.ru/bubbling-and-capturing). Так исторически сложилось, что options может быть `false`/`true`, это тоже самое, что `{capture: false/true}`.

- `passive`: если `true`, то указывает, что обработчик никогда не вызовет `preventDefault()`, подробнее об этом будет рассказано в главе Действия браузера по умолчанию.


### Для удаления обработчика следует использовать `removeEventListener`:
```
element.removeEventListener(event, handler[, options]);
```


 

***

[Грамматика и типы](https://developer.mozilla.org/ru/docs/Web/JavaScript/Guide/Grammar_and_types)

[Структура кода](https://learn.javascript.ru/structure)

[Особенности JavaScript](https://learn.javascript.ru/javascript-specials)

[Переменные](https://learn.javascript.ru/variables)

[Функции](https://learn.javascript.ru/function-basics)

[Function Expression (Функциональное Выражение)](https://learn.javascript.ru/function-expressions)

[Типы данных](https://learn.javascript.ru/types)


[Курс JavaScript - Основные концепции и особенности разработки](http://jsflow.org/)


[Введение в браузерные события](https://learn.javascript.ru/introduction-browser-events)

[Браузерное окружение, спецификации](https://learn.javascript.ru/browser-environment)

[DOM-дерево](https://learn.javascript.ru/dom-nodes)


[Используем console.log() в Chrome на полную](https://habr.com/ru/post/480700/)
